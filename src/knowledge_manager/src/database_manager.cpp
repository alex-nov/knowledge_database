#include "database_manager.hpp"

#include <fmt/core.h>
#include <fmt/xchar.h>
#include <logger/logger.h>

#include "utils/utils.hpp"

#define log_error_m   alog::logger().error   (alog_line_location, "DatabaseManager")
#define log_info_m    alog::logger().info    (alog_line_location, "DatabaseManager")
#define log_debug_m   alog::logger().debug   (alog_line_location, "DatabaseManager")

void DatabaseManager::Init( const database::DatabaseOptions & db_options )
{
    log_info_m << "DatabaseManager::Init : " + db_options.Tostring();
    if( db_options.IsValid() )
    {
        _db_options = db_options;
    }
    //else use default

    auto connect_string = fmt::format( "dbname = {0} user = {1} password = '{2}' {3} = {4} port = {5}",
                            _db_options.dbname,                                               // 0
                            _db_options.user,                                                 // 1
                            _db_options.password,                                             // 2
                            utils::is_IP(_db_options.hostaddr.c_str()) ? "hostaddr" : "host", // 3
                            _db_options.hostaddr,                                             // 4
                            _db_options.port );                                               // 5

    _conn_ptr = std::make_unique<pqxx::connection>( connect_string );
    if( !_conn_ptr )
    {
        log_error_m << "DatabaseManager::Init fail to connect to DB";
        return;
    }
    else
    {
        log_info_m << "DatabaseManager::Init connected to DB successfully";
    }

    pqxx::work tx{ *_conn_ptr };

    try
    {
        // TODO:
        // * make c++ tables structures
        // * check fields to delete/create with alter

        auto result = tx.exec( "CREATE SCHEMA IF NOT EXISTS storage;" );

        result = tx.exec( "CREATE TABLE IF NOT EXISTS storage.themes ( "
                        "id text PRIMARY KEY NOT NULL, "
                        "name text);" );

        result = tx.exec( "CREATE TABLE IF NOT EXISTS storage.units ( "
                        "id text PRIMARY KEY NOT NULL, "
                        "title text, "
                        "theme_uuid text REFERENCES storage.themes (id) ON DELETE CASCADE NOT NULL, "
                        "unit_text text, "
                        "local_path varchar, "
                        "content_url varchar, "
                        "timestamp bigint NOT NULL);" );

        result = tx.exec( "CREATE TABLE IF NOT EXISTS storage.index ( "
                        "id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, "
                        "theme_uuid text REFERENCES storage.themes (id) ON DELETE CASCADE NOT NULL, "
                        "parent_id text, "
                        "unit_uuid text REFERENCES storage.units (id) ON DELETE CASCADE NOT NULL);" );

        tx.commit();

    }
    catch( const std::exception& e )
    {
        log_error_m << "DatabaseManager::Init create schema exception : " << e.what();
        tx.abort();
    }
}

void DatabaseManager::ClearDB()
{
    log_info_m << "DatabaseManager::ClearDB";
    if( !_conn_ptr )
    {
        log_error_m << "DatabaseManager::ClearDB connection error";
        return;
    }

    pqxx::work tx{ *_conn_ptr };
    try
    {
        auto result = tx.exec( "DELETE FROM storage.index CASCADE;" );
        result = tx.exec( "DELETE FROM storage.units CASCADE;" );
        result = tx.exec( "DELETE FROM storage.themes CASCADE;" );
        tx.commit();
    }
    catch (const std::exception& e)
    {
        tx.abort();
        log_error_m << "DatabaseManager::ClearDB deleting exception: " << e.what();
        return;
    }
}

bool DatabaseManager::Ping()
{
    log_info_m << "DatabaseManager::Ping";
    if( !_conn_ptr )
    {
        log_error_m << "DatabaseManager::Ping connection error";
        return false;
    }

    pqxx::work tx{ *_conn_ptr };
    try
    {
        auto result = tx.exec( "Select 1;" );
        tx.commit();
    }
    catch (const std::exception& e)
    {
        log_error_m << "DatabaseManager::Ping exception: " << e.what();
        return false;
    }

    return true;
}

bool DatabaseManager::InsertTheme( const ThemeTuple & theme )
{
    log_info_m << "DatabaseManager::InsertTheme \"" << theme.uuid << "\"";
    if( !_conn_ptr )
    {
        log_error_m << "DatabaseManager::InsertTheme connection error";
        return false;
    }

    pqxx::work tx{ *_conn_ptr };
    try
    {
        std::string query_text = fmt::format("INSERT INTO storage.themes ( id, name ) VALUES ( '{0}', '{1}' ) ON CONFLICT DO NOTHING;",
                                            theme.uuid,  // 0
                                            theme.name); // 1
        auto result = tx.exec(query_text);
        tx.commit();
    }
    catch (const std::exception& e)
    {
        log_error_m << "DatabaseManager::InsertTheme exception: " << e.what();
        tx.abort();
        return false;
    }

    return true;
}

ThemeTuple DatabaseManager::GetTheme( const std::string & theme_uuid ) const
{
    log_info_m << "DatabaseManager::GetTheme \"" << theme_uuid << "\"";
    ThemeTuple res;
    if( !_conn_ptr )
    {
        log_error_m << "DatabaseManager::GetTheme connection error";
        return res;
    }

    pqxx::work tx{ *_conn_ptr };
    try
    {
        std::string query_text = fmt::format( "SELECT * FROM storage.themes WHERE id='{}';", theme_uuid );
        auto result = tx.exec( query_text );

        if( result.affected_rows() == 0 )
        {
            throw "there is no theme";
        }
        tx.commit();

        auto row = result.back();
        res.uuid = row[ "id" ].as< std::string >();
        res.name = row[ "name" ].as< std::string >();
    }
    catch( const std::exception& e )
    {
        log_error_m << "DatabaseManager::GetTheme exception: " << e.what();
        tx.abort();
    }

    return res;
}

ThemeTuple DatabaseManager::GetThemeByUnitId(const std::string & unit_uuid) const
{
    log_info_m << "DatabaseManager::GetThemeByUnitId unit_uuid = \"" << unit_uuid << "\"";

    if( !_conn_ptr )
    {
        log_error_m << "DatabaseManager::GetThemeByUnitId connection error";
        return {};
    }

    pqxx::work tx{ *_conn_ptr };
    ThemeTuple res;
    try
    {
        std::string query_text = fmt::format( "SELECT st.* FROM storage.themes AS st "
                                                "JOIN storage.units AS su ON st.id=su.theme_uuid "
                                                "WHERE su.id='{}';", unit_uuid );
        auto result = tx.exec( query_text );

        if( result.affected_rows() == 0 )
        {
            throw "there is no theme";
        }

        tx.commit();

        auto row = result.back();
        res.uuid = row[ "id" ].as< std::string >();
        res.name = row[ "name" ].as< std::string >();
    }
    catch( const std::exception& e )
    {
        log_error_m << "DatabaseManager::GetThemeByUnitId exception: " << e.what();
        tx.abort();
    }

    return res;
}

std::vector< ThemeTuple > DatabaseManager::GetAllThemes() const
{
    log_info_m << "DatabaseManager::GetAllThemes";
    if( !_conn_ptr )
    {
        log_error_m << "DatabaseManager::GetAllThemes connection error";
        return {};
    }

    std::vector< ThemeTuple > res;
    pqxx::work tx{ *_conn_ptr };
    try
    {
        std::string query_text = fmt::format( "SELECT * FROM storage.themes;" );
        auto result = tx.exec( query_text );

        if( result.affected_rows() == 0 )
        {
            throw "there is no themes";
        }
        tx.commit();

        for( auto row : result )
        {
            ThemeTuple theme;
            theme.uuid = row[ "id" ].as< std::string >();
            theme.name = row[ "name" ].as< std::string >();
            res.push_back(theme);
        }
    }
    catch( const std::exception& e )
    {
        log_error_m << "DatabaseManager::GetAllThemes exception: " << e.what();
        tx.abort();
    }

    return res;
}

bool DatabaseManager::InsertUnitWithIndex( const std::shared_ptr< ContentUnit > unit,
                                           const std::shared_ptr< ContentIndexUnit > index_unit )
{
    log_info_m << "DatabaseManager::InsertUnit unit_uuid = \"" << unit->GetUuid() << "\"";
    if( !_conn_ptr )
    {
        log_error_m << "DatabaseManager::InsertUnit connection error";
        return false;
    }

    pqxx::work tx{ *_conn_ptr };
    try
    {
        // insert unit
        auto time_str = std::to_string( unit->timestamp );
        std::string query_text = fmt::format( "INSERT INTO storage.units ( id, title, theme_uuid, unit_text, local_path, content_url, timestamp ) "
                                              "VALUES ( '{0}', '{1}', '{2}', '{3}', '{4}', '{5}', {6} ) ON CONFLICT DO NOTHING;",
                                              unit->uuid,       // 0
                                              unit->title,      // 1
                                              unit->theme_uuid, // 2
                                              unit->text,       // 3
                                              unit->local_path, // 4
                                              unit->content_url,// 5
                                              time_str.substr(0, 10));// 6
        auto result = tx.exec( query_text );
        if ( result.affected_rows() == 0 )
        {
            throw "can't save unit";
        }

        // insert unit index
        query_text = fmt::format("INSERT INTO storage.index ( theme_uuid, parent_id, unit_uuid ) "
                                             "VALUES ( '{0}', '{1}', '{2}' ) ON CONFLICT DO NOTHING RETURNING id;",
                                            index_unit->theme_uuid,  // 0
                                            index_unit->parent_uuid, // 1
                                            index_unit->unit_uuid);  // 2
        result = tx.exec( query_text );
        if ( result.affected_rows() == 0 )
        {
            throw "can't save unit index";
        }

        tx.commit();
    }
    catch( const std::exception& e )
    {
        log_error_m << "DatabaseManager::InsertUnit exception: " << e.what();
        tx.abort();
        return false;
    }

    return true;
}

std::shared_ptr<ContentUnit> DatabaseManager::GetUnit( const std::string & unit_uuid ) const
{
    log_info_m << "DatabaseManager::GetUnit unit_uuid = \"" << unit_uuid << "\"";
    std::shared_ptr< ContentUnit > res;
    if ( !_conn_ptr )
    {
        log_error_m << "DatabaseManager::GetUnit connection error";
        return res;
    }

    pqxx::work tx{ *_conn_ptr };
    try
    {
        std::string query_text = fmt::format("SELECT * FROM storage.units WHERE id='{}';", unit_uuid);
        auto result = tx.exec( query_text );

        if (result.affected_rows() == 0)
        {
            throw "there is no units with uuid";
        }
        tx.commit();

        auto row = result.back();
        res = std::make_shared<ContentUnit>();
        res->uuid        = row[ "id" ].as< std::string >();
        res->title       = row[ "title" ].as< std::string >();
        res->theme_uuid  = row[ "theme_uuid" ].as< std::string >();
        res->text        = row[ "unit_text" ].as< std::string >();
        res->local_path  = row[ "local_path" ].as< std::string >();
        res->content_url = row[ "content_url" ].as< std::string >();
        res->timestamp   = row[ "timestamp" ].as< time_t >();
    }
    catch (const std::exception& e)
    {
        log_error_m << "DatabaseManager::GetUnit exception: " << e.what();
        tx.abort();
    }

    return res;
}

bool DatabaseManager::ModifyUnit( const std::string & unit_uuid, const std::string & field, const std::string & value )
{
    log_info_m << "DatabaseManager::ModifyUnit unit_uuid = \"" << unit_uuid << "\""
               << " field \"" << field << "\""
               << " value \"" << value << "\"";

    pqxx::work tx{ *_conn_ptr };
    try
    {
        std::string query_text = fmt::format( "UPDATE {0}.{1} as u SET {2} = '{3}' WHERE u.id = '{4}';",
                                                database::schema,           // 0
                                                database::units_table_name, // 1
                                                field,                      // 2
                                                value,                      // 3
                                                unit_uuid );                // 4
        auto result = tx.exec( query_text );
        if( result.affected_rows() == 0 )
        {
            throw "unit wasn't changed";
        }
        tx.commit();
    }
    catch( const std::exception& e )
    {
        log_error_m << "DatabaseManager::GetIndexForTheme exception: " << e.what();
        tx.abort();
    }

    return true;
}

std::vector< std::shared_ptr<ContentIndexUnit > > DatabaseManager::GetIndexForTheme( const std::string & theme_id ) const
{
    if ( !_conn_ptr || theme_id.empty() )
    {
        log_error_m << "DatabaseManager::GetIndexForTheme connection error";
        return {};
    }

    std::vector< std::shared_ptr<ContentIndexUnit> > res;
    pqxx::work tx{ *_conn_ptr };
    try
    {
        std::string query_text = fmt::format( "SELECT * FROM storage.index WHERE theme_uuid = '{}';", theme_id );
        auto result = tx.exec( query_text );
        tx.commit();

        for (auto row : result)
        {
            auto index_unit = std::make_shared<ContentIndexUnit>(row[ "id" ].as< int32_t >(),
                                                                row[ "theme_uuid" ].as< std::string >(),
                                                                row[ "parent_id" ].as< std::string >(),
                                                                row[ "unit_uuid" ].as< std::string >());
            res.push_back( index_unit );
        }
    }
    catch( const std::exception& e )
    {
        log_error_m << "DatabaseManager::GetIndexForTheme exception: " << e.what();
        tx.abort();
    }

    return res;
}

bool DatabaseManager::DeleteFromTable( const std::variant<std::string, int> & id, const std::string & table )
{
    if( !_conn_ptr )
    {
        log_error_m << "DatabaseManager::DeleteFromTable connection error";
        return false;
    }

    std::string id_text;
    std::string query_text;
    if( std::holds_alternative< int >( id ) )
    {
        id_text = std::to_string( std::get< int >( id ) );
        query_text = fmt::format( "DELETE FROM {0}.{1} WHERE id={2};",
                                            database::schema,       // 1
                                            table,                  // 2
                                            id_text);               // 3
    }
    else if( std::holds_alternative< std::string >( id ) )
    {
        id_text = std::get< string >( id );
        query_text = fmt::format( "DELETE FROM {0}.{1} WHERE id='{2}';",
                                            database::schema,       // 1
                                            table,                  // 2
                                            id_text);               // 3
    }
    else
    {
        log_error_m << "DatabaseManager::DeleteFromTable : wrong id type";
        return false;
    }

    log_info_m << "DatabaseManager::DeleteFromTable id = \"" << id_text << "\"" << " from table \"" << table << "\"";

    bool res = false;
    pqxx::work tx{ *_conn_ptr };
    try
    {
        auto result = tx.exec( query_text );
        res = result.affected_rows() != 0;
        tx.commit();
    }
    catch( const std::exception& e )
    {
        log_error_m << "DatabaseManager::DeleteFromTable exception: " << e.what();
        tx.abort();
    }

    return res;
}

bool DatabaseManager::DeleteUnitsByTheme( const std::string & theme_id )
{
    log_info_m << "DatabaseManager::DeleteUnitsByTheme theme_id = \"" << theme_id << "\"";

    if( !_conn_ptr )
    {
        log_error_m << "DatabaseManager::DeleteUnitsByTheme connection error";
        return false;
    }

    bool res = false;
    pqxx::work tx{ *_conn_ptr };
    try
    {
        std::string query_text = fmt::format( "SELECT * FROM {0}.{1} WHERE theme_uuid='{2}';",
                                            database::schema,           // 0
                                            database::units_table_name, // 1
                                            theme_id );                 // 2
        auto result = tx.exec( query_text );
        if( result.affected_rows() == 0 )
        {
            // if there is no units - no need to delete anything
            tx.commit();
            return true;
        }

        query_text = fmt::format( "DELETE FROM {0}.{1} WHERE theme_uuid='{2}';",
                                            database::schema,           // 0
                                            database::units_table_name, // 1
                                            theme_id );                 // 2

        result = tx.exec( query_text );
        res = result.affected_rows() != 0;
        tx.commit();
    }
    catch( const std::exception& e )
    {
        log_error_m << "DatabaseManager::DeleteUnitsByTheme exception: " << e.what();
        tx.abort();
    }

    return res;
}

#undef log_error_m
#undef log_info_m
#undef log_debug_m
