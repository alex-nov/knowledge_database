#include "database_manager.hpp"

#include <fmt/core.h>
#include <fmt/xchar.h>

#include "utils/utils.hpp"

void DatabaseManager::Init( std::string db_options_str )
{
    if (!db_options_str.empty())
    {
        //TODO : parse optins
    }
    //else use default

    auto connect_string = fmt::format("dbname = {0} user = {1} password = {2} {3} = {4} port = {5}",
                            _db_options.dbname,                                             // 0
                            _db_options.user,                                               // 1
                            _db_options.password,                                           // 2
                            utils::isIP(_db_options.hostaddr.c_str()) ? "hostaddr" : "host",// 3
                            _db_options.hostaddr,                                           // 4
                            _db_options.port);                                              // 5


    _conn_ptr = std::make_unique<pqxx::connection>(connect_string);
    if (!_conn_ptr)
    {
        // log connection error
        return;
    }

    pqxx::work tx{ *_conn_ptr };

    try
    {
        // TODO:
        // * make tables structures
        // * check fields to delete/create with alter

        auto result = tx.exec("CREATE SCHEMA IF NOT EXISTS storage;");

        result = tx.exec("CREATE TABLE IF NOT EXISTS storage.themes ( "
                        "id uuid PRIMARY KEY NOT NULL"
                        "name varchar[256] );");

        result = tx.exec("CREATE TABLE IF NOT EXISTS storage.units ( "
                        "id uuid PRIMARY KEY NOT NULL, "
                        "title varchar[256], "
                        "theme_uuid uuid REFERENCES storage.themes (id) NOT NULL, "
                        "unit_text text, "
                        "local_path varchar, "
                        "content_url varchar, "
                        "timestamp date NOT NULL);");

        result = tx.exec("CREATE TABLE IF NOT EXISTS storage.trees ( "
                        "id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, "
                        "theme_uuid uuid REFERENCES storage.themes (id) NOT NULL, "
                        "parent_id uuid, "
                        "unit_uuid uuid REFERENCES storage.units (id) NOT NULL);");

        tx.commit();

    }
    catch(const std::exception& e)
    {
        // TODO: log error
    }
}

bool DatabaseManager::InsertTheme(const ThemeTuple & theme)
{
    if (!_conn_ptr)
    {
        std::string query_text = fmt::format("");
        // log connection error
        return false;
    }

    pqxx::work tx{ *_conn_ptr };
    try
    {
        std::string query_text = fmt::format("INSERT INTO storage.themes ( id, name ) VALUES ( '{0}', {1} )", theme.uuid, theme.name);
        auto result = tx.exec(query_text);
        tx.commit();
    }
    catch(const std::exception& e)
    {
        tx.abort();
        //TODO log error
        std::cerr << e.what() << '\n';
        return false;
    }

    return true;
}

ThemeTuple DatabaseManager::GetTheme(std::string theme_uuid)
{
    ThemeTuple res;
    if (!_conn_ptr)
    {
        std::string query_text = fmt::format("");
        // log connection error
        return res;
    }

    pqxx::work tx{ *_conn_ptr };
    try
    {
        std::string query_text = fmt::format("SELECT FROM storage.themes * WHERE id='{}')", theme_uuid);
        auto result = tx.exec( query_text );
        tx.commit();

        if( result.affected_rows() == 0)
        {
            return res;
        }

        auto row = result.back();
        res.uuid = row["id"].as<std::string>();
        res.name = row["name"].as<std::string>();
    }
    catch(const std::exception& e)
    {
        tx.abort();
        //TODO log error
        std::cerr << e.what() << '\n';
        return {};
    }

    return res;
}

bool DatabaseManager::SaveUnit( std::shared_ptr<ContentUnit> unit )
{
    if (!_conn_ptr)
    {
        std::string query_text = fmt::format("");
        // log connection error
        return false;
    }

    pqxx::work tx{ *_conn_ptr };

    //std::string query("INSERT INTO ");

    return true;
}

std::shared_ptr<ContentUnit> DatabaseManager::LoadUnit( std::string & unit_uuid )
{

    return std::shared_ptr<ContentUnit>();
}

std::vector< std::shared_ptr<ContentUnit> > DatabaseManager::LoadTheme( std::string & theme_uuid )
{

    return {};
}
