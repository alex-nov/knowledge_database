#include "database_manager.hpp"

#include <fmt/core.h>
#include <fmt/xchar.h>

#include "utils/utils.hpp"

void DatabaseManager::Init(const database::DatabaseOptions & db_options )
{
    if (db_options.IsValid())
    {
        _db_options = db_options;
    }
    //else use default

    auto connect_string = fmt::format("dbname = {0} user = {1} password = '{2}' {3} = {4} port = {5}",
                            _db_options.dbname,                                             // 0
                            _db_options.user,                                               // 1
                            _db_options.password,                                           // 2
                            utils::is_IP(_db_options.hostaddr.c_str()) ? "hostaddr" : "host",// 3
                            _db_options.hostaddr,                                           // 4
                            _db_options.port);                                              // 5

    _conn_ptr = std::make_unique<pqxx::connection>(connect_string);
    if (!_conn_ptr)
    {
        // log connection error
        return;
    }
    else
    {
        // log connection success
    }

    pqxx::work tx{ *_conn_ptr };

    try
    {
        // TODO:
        // * make tables structures
        // * check fields to delete/create with alter

        auto result = tx.exec("CREATE SCHEMA IF NOT EXISTS storage;");

        result = tx.exec("CREATE TABLE IF NOT EXISTS storage.themes ( "
                        "id text PRIMARY KEY NOT NULL, "
                        "name text);");

        result = tx.exec("CREATE TABLE IF NOT EXISTS storage.units ( "
                        "id text PRIMARY KEY NOT NULL, "
                        "title text, "
                        "theme_uuid text REFERENCES storage.themes (id) ON DELETE CASCADE NOT NULL, "
                        "unit_text text, "
                        "local_path varchar, "
                        "content_url varchar, "
                        "timestamp bigint NOT NULL);");

        result = tx.exec("CREATE TABLE IF NOT EXISTS storage.index ( "
                        "id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, "
                        "theme_uuid text REFERENCES storage.themes (id) ON DELETE CASCADE NOT NULL, "
                        "parent_id text, "
                        "unit_uuid text REFERENCES storage.units (id) ON DELETE CASCADE NOT NULL);");

        tx.commit();

    }
    catch (const std::exception& e)
    {
        // TODO: log error
        tx.abort();
    }
}

void DatabaseManager::ClearDB()
{
    if (!_conn_ptr)
    {
        // log connection error
        return;
    }

    pqxx::work tx{ *_conn_ptr };
    try
    {
        auto result = tx.exec( "DELETE FROM storage.index CASCADE;" );
        result = tx.exec( "DELETE FROM storage.units CASCADE;" );
        result = tx.exec( "DELETE FROM storage.themes CASCADE;" );
        tx.commit();
    }
    catch (const std::exception& e)
    {
        std::cerr << e.what() << '\n';
        tx.abort();
        //TODO log error
        return;
    }
}

bool DatabaseManager::Ping()
{
    if (!_conn_ptr)
    {
        // log connection error
        return false;
    }

    pqxx::work tx{ *_conn_ptr };
    try
    {
        auto result = tx.exec( "Select 1;" );
        tx.commit();
    }
    catch (const std::exception& e)
    {
        std::cerr << e.what() << '\n';
        return false;
    }
    return true;
}

bool DatabaseManager::InsertTheme(const ThemeTuple & theme)
{
    if (!_conn_ptr)
    {
        // log connection error
        return false;
    }

    pqxx::work tx{ *_conn_ptr };
    try
    {
        std::string query_text = fmt::format("INSERT INTO storage.themes ( id, name ) VALUES ( '{0}', '{1}' ) ON CONFLICT DO NOTHING;",
                                            theme.uuid,  // 0
                                            theme.name); // 1
        auto result = tx.exec(query_text);
        tx.commit();
    }
    catch (const std::exception& e)
    {
        std::cerr << e.what() << '\n';
        tx.abort();
        //TODO log error
        return false;
    }

    return true;
}

ThemeTuple DatabaseManager::GetTheme(const std::string & theme_uuid) const
{
    ThemeTuple res;
    if (!_conn_ptr)
    {
        // log connection error
        return res;
    }

    pqxx::work tx{ *_conn_ptr };
    try
    {
        std::string query_text = fmt::format("SELECT * FROM storage.themes WHERE id='{}';", theme_uuid);
        auto result = tx.exec( query_text );
        tx.commit();

        if (result.affected_rows() == 0)
        {
            return res;
        }

        auto row = result.back();
        res.uuid = row["id"].as<std::string>();
        res.name = row["name"].as<std::string>();
    }
    catch (const std::exception& e)
    {
        std::cerr << e.what() << '\n';
        tx.abort();
        //TODO log error
    }

    return res;
}

std::vector<ThemeTuple> DatabaseManager::GetAllThemes() const
{
    if (!_conn_ptr)
    {
        // log connection error
        return {};
    }

    std::vector<ThemeTuple> res;
    pqxx::work tx{ *_conn_ptr };
    try
    {
        std::string query_text = fmt::format("SELECT * FROM storage.themes;");
        auto result = tx.exec( query_text );
        tx.commit();

        if (result.affected_rows() == 0)
        {
            return {};
        }

        for (auto row : result)
        {
            ThemeTuple theme;
            theme.uuid = row["id"].as<std::string>();
            theme.name = row["name"].as<std::string>();
            res.push_back(theme);
        }
    }
    catch (const std::exception& e)
    {
        std::cerr << e.what() << '\n';
        tx.abort();
        //TODO log error
    }

    return res;
}

bool DatabaseManager::InsertUnit(const std::shared_ptr<ContentUnit> unit )
{
    if (!_conn_ptr)
    {
        // log connection error
        return false;
    }

    pqxx::work tx{ *_conn_ptr };
    try
    {
        auto time_str = std::to_string(unit->timestamp);
        std::string query_text = fmt::format("INSERT INTO storage.units ( id, title, theme_uuid, unit_text, local_path, content_url, timestamp ) "
                                             "VALUES ( '{0}', '{1}', '{2}', '{3}', '{4}', '{5}', {6} ) ON CONFLICT DO NOTHING;",
                                             unit->uuid,       // 0
                                             unit->title,      // 1
                                             unit->theme_uuid, // 2
                                             unit->text,       // 3
                                             unit->local_path, // 4
                                             unit->content_url,// 5
                                             time_str.substr(0, 10));// 6
        auto result = tx.exec( query_text );
        tx.commit();

        if (result.affected_rows() == 0)
        {
            return false;
        }
    }
    catch (const std::exception& e)
    {
        std::cerr << e.what() << '\n';
        tx.abort();
        //TODO log error
        return false;
    }

    return true;
}

std::shared_ptr<ContentUnit> DatabaseManager::GetUnit(const std::string & unit_uuid ) const
{
    std::shared_ptr<ContentUnit> res;
    if (!_conn_ptr)
    {
        // log connection error
        return res;
    }

    pqxx::work tx{ *_conn_ptr };
    try
    {
        std::string query_text = fmt::format("SELECT * FROM storage.units WHERE id='{}';", unit_uuid);
        auto result = tx.exec( query_text );
        tx.commit();

        if (result.affected_rows() == 0)
        {
            // TODO: log error
            return res;
        }

        auto row = result.back();
        res = std::make_shared<ContentUnit>();
        res->uuid        = row["id"].as<std::string>();
        res->title       = row["title"].as<std::string>();
        res->theme_uuid  = row["theme_uuid"].as<std::string>();
        res->text        = row["unit_text"].as<std::string>();
        res->local_path  = row["local_path"].as<std::string>();
        res->content_url = row["content_url"].as<std::string>();
        res->timestamp   = row["timestamp"].as<time_t>();
    }
    catch (const std::exception& e)
    {
        std::cerr << e.what() << '\n';
        tx.abort();
        //TODO log error
    }

    return res;
}

int32_t DatabaseManager::InsertIndexUnit(std::shared_ptr<ContentIndexUnit> index_unit)
{
    int32_t res = -1;
    if (!_conn_ptr || !index_unit)
    {
        // log connection error
        return res;
    }

    pqxx::work tx{ *_conn_ptr };
    try
    {
        std::string query_text = fmt::format("INSERT INTO storage.index ( theme_uuid, parent_id, unit_uuid ) "
                                             "VALUES ( '{0}', '{1}', '{2}' ) ON CONFLICT DO NOTHING RETURNING id;",
                                            index_unit->theme_uuid,  // 0
                                            index_unit->parent_uuid, // 1
                                            index_unit->unit_uuid);  // 2
        auto result = tx.exec(query_text);
        tx.commit();


        if (result.affected_rows() == 0)
        {
            // TODO: log error
            return res;
        }

        auto row = result.back();
        res = row["id"].as<int32_t>();
    }
    catch (const std::exception& e)
    {
        std::cerr << e.what() << '\n';
        tx.abort();
        //TODO log error
        return -1;
    }

    return res;
}

std::vector< std::shared_ptr<ContentIndexUnit> > DatabaseManager::GetIndexForTheme(const std::string & theme_id) const
{
    if (!_conn_ptr || theme_id.empty())
    {
        // log connection error
        return {};
    }

    std::vector< std::shared_ptr<ContentIndexUnit> > res;
    pqxx::work tx{ *_conn_ptr };
    try
    {
        std::string query_text = fmt::format("SELECT * FROM storage.index WHERE theme_uuid = '{}';", theme_id);
        auto result = tx.exec( query_text );
        tx.commit();

        for (auto row : result)
        {
            auto index_unit = std::make_shared<ContentIndexUnit>(row["id"].as<int32_t>(),
                                                                row["theme_uuid"].as<std::string>(),
                                                                row["parent_id"].as<std::string>(),
                                                                row["unit_uuid"].as<std::string>());
            res.push_back(index_unit);
        }
    }
    catch (const std::exception& e)
    {
        std::cerr << e.what() << '\n';
        tx.abort();
        //TODO log error
    }

    return res;
}

bool DatabaseManager::DeleteFromTable(const std::variant<std::string, int> & id, const std::string & table)
{
    bool res = false;
    if (!_conn_ptr)
    {
        std::cerr << "DatabaseManager::DeleteFromTable: wrong id type for " << database::index_table_name << '\n';
        // log connection error
        return res;
    }

    if (std::holds_alternative<int>(id) && table != database::index_table_name)
    {
        // log connection error
        return res;
    }

    pqxx::work tx{ *_conn_ptr };
    try
    {
        std::string query_text;
        if (std::holds_alternative<int>(id))
        {
            query_text = fmt::format("DELETE FROM {0}.{1} WHERE id={2};",
                                            database::schema,   // 1
                                            table,              // 2
                                            std::get<int>(id)); // 3
        }
        else if (std::holds_alternative<std::string>(id))
        {
            query_text = fmt::format("DELETE FROM {0}.{1} WHERE id='{2}';",
                                            database::schema,       // 0
                                            table,                  // 1
                                            std::get<string>(id));  // 2
        }
        else
        {
            throw std::runtime_error("DatabaseManager::DeleteFromTable : wrong id type");
        }

        auto result = tx.exec( query_text );
        tx.commit();
        res = result.affected_rows() != 0;
    }
    catch (const std::exception& e)
    {
        std::cerr << e.what() << '\n';
        tx.abort();
        //TODO log error
    }

    return res;
}
